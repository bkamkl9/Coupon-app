create table "public"."Stats" (
    "id" bigint generated by default as identity not null,
    "reference" uuid not null,
    "event_type" text not null,
    "time" timestamp with time zone not null default (now() AT TIME ZONE 'utc'::text)
);


alter table "public"."Stats" enable row level security;

CREATE UNIQUE INDEX "Stats_pkey" ON public."Stats" USING btree (id);

alter table "public"."Stats" add constraint "Stats_pkey" PRIMARY KEY using index "Stats_pkey";

alter table "public"."Stats" add constraint "Stats_reference_fkey" FOREIGN KEY (reference) REFERENCES "Coupons"(id) ON DELETE CASCADE not valid;

alter table "public"."Stats" validate constraint "Stats_reference_fkey";

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION public.enforce_favourite_count_update()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
begin
  -- Ensure only favourite_count is updated
  if (
    (new.id          is distinct from old.id) or
    (new.status      is distinct from old.status) or
    (new.title       is distinct from old.title) or
    (new.description is distinct from old.description) or
    (new.link        is distinct from old.link) or
    (new.code        is distinct from old.code) or
    (new.image_url   is distinct from old.image_url) or
    (new.currency    is distinct from old.currency) or
    (new.price       is distinct from old.price) or
    (new.scheduled_for is distinct from old.scheduled_for) or
    (new.created_at  is distinct from old.created_at)
  ) then
    raise exception 'Only favourite_count can be updated by anon user';
  end if;

  -- Ensure favourite_count changes by +1 or -1
  if abs(new.favourite_count - old.favourite_count) != 1 then
    raise exception 'favourite_count must change by exactly +1 or -1';
  end if;

  -- Ensure it never goes below 0
  if new.favourite_count < 0 then
    raise exception 'favourite_count cannot be negative';
  end if;

  return new;
end;
$function$
;

grant delete on table "public"."Stats" to "anon";

grant insert on table "public"."Stats" to "anon";

grant references on table "public"."Stats" to "anon";

grant select on table "public"."Stats" to "anon";

grant trigger on table "public"."Stats" to "anon";

grant truncate on table "public"."Stats" to "anon";

grant update on table "public"."Stats" to "anon";

grant delete on table "public"."Stats" to "authenticated";

grant insert on table "public"."Stats" to "authenticated";

grant references on table "public"."Stats" to "authenticated";

grant select on table "public"."Stats" to "authenticated";

grant trigger on table "public"."Stats" to "authenticated";

grant truncate on table "public"."Stats" to "authenticated";

grant update on table "public"."Stats" to "authenticated";

grant delete on table "public"."Stats" to "service_role";

grant insert on table "public"."Stats" to "service_role";

grant references on table "public"."Stats" to "service_role";

grant select on table "public"."Stats" to "service_role";

grant trigger on table "public"."Stats" to "service_role";

grant truncate on table "public"."Stats" to "service_role";

grant update on table "public"."Stats" to "service_role";

create policy "allow all for auth users"
on "public"."Stats"
as permissive
for all
to authenticated
using (true);


create policy "stats insert"
on "public"."Stats"
as permissive
for insert
to anon
with check (true);


